"""
Vulnerability Assessment Engine

Implements automated vulnerability scanning, weakness identification and prioritization,
and attack surface analysis for comprehensive security assessment.
"""

import asyncio
import time
import socket
import ssl
import hashlib
import re
from dataclasses import dataclass, field
from typing import List, Dict, Optional, Set, Tuple, Any
from enum import Enum
import logging
from concurrent.futures import ThreadPoolExecutor
import json

from .resolver import TargetInfo, ServiceInfo
from .profiler import ServiceFingerprint, DefenseProfile

logger = logging.getLogger(__name__)

class VulnerabilityType(Enum):
    """Types of vulnerabilities"""
    BUFFER_OVERFLOW = "buffer_overflow"
    SQL_INJECTION = "sql_injection"
    XSS = "cross_site_scripting"
    CSRF = "cross_site_request_forgery"
    DIRECTORY_TRAVERSAL = "directory_traversal"
    COMMAND_INJECTION = "command_injection"
    WEAK_AUTHENTICATION = "weak_authentication"
    INSECURE_TRANSPORT = "insecure_transport"
    INFORMATION_DISCLOSURE = "information_disclosure"
    DENIAL_OF_SERVICE = "denial_of_service"
    AMPLIFICATION_VECTOR = "amplification_vector"
    REFLECTION_VECTOR = "reflection_vector"
    PROTOCOL_WEAKNESS = "protocol_weakness"
    CONFIGURATION_ERROR = "configuration_error"
    OUTDATED_SOFTWARE = "outdated_software"

class Severity(Enum):
    """Vulnerability severity levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"

@dataclass
class Vulnerability:
    """Individual vulnerability finding"""
    vuln_type: VulnerabilityType
    severity: Severity
    title: str
    description: str
    affected_service: str
    port: int
    protocol: str
    evidence: List[str] = field(default_factory=list)
    exploitation_difficulty: str = "medium"  # easy, medium, hard
    attack_vectors: List[str] = field(default_factory=list)
    remediation: List[str] = field(default_factory=list)
    cvss_score: Optional[float] = None
    cve_references: List[str] = field(default_factory=list)
    discovered_at: float = field(default_factory=time.time)

@dataclass
class AttackSurface:
    """Attack surface analysis"""
    total_services: int = 0
    exposed_services: List[str] = field(default_factory=list)
    attack_vectors: Dict[str, List[str]] = field(default_factory=dict)
    amplification_potential: float = 0.0
    reflection_potential: float = 0.0
    dos_susceptibility: float = 0.0
    overall_risk_score: float = 0.0

@dataclass
class VulnerabilityReport:
    """Comprehensive vulnerability assessment report"""
    target: str
    scan_time: float = field(default_factory=time.time)
    vulnerabilities: List[Vulnerability] = field(default_factory=list)
    attack_surface: AttackSurface = field(default_factory=AttackSurface)
    risk_summary: Dict[str, int] = field(default_factory=dict)
    recommendations: List[str] = field(default_factory=list)
    scan_coverage: Dict[str, bool] = field(default_factory=dict)

class VulnerabilityDatabase:
    """Database of known vulnerabilities and attack patterns"""
    
    def __init__(self):
        self.service_vulnerabilities = self._load_service_vulnerabilities()
        self.protocol_weaknesses = self._load_protocol_weaknesses()
        self.amplification_services = self._load_amplification_services()
    
    def _load_service_vulnerabilities(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load known service vulnerabilities"""
        return {
            'http': [
                {
                    'type': VulnerabilityType.XSS,
                    'severity': Severity.MEDIUM,
                    'title': 'Potential Cross-Site Scripting',
                    'description': 'HTTP service may be vulnerable to XSS attacks',
                    'test_payloads': ['<script>alert(1)</script>', '"><img src=x onerror=alert(1)>'],
                    'indicators': ['script', 'alert', 'onerror']
                },
                {
                    'type': VulnerabilityType.SQL_INJECTION,
                    'severity': Severity.HIGH,
                    'title': 'SQL Injection Vulnerability',
                    'description': 'HTTP parameters may be vulnerable to SQL injection',
                    'test_payloads': ["' OR '1'='1", "1' UNION SELECT NULL--", "'; DROP TABLE users--"],
                    'indicators': ['sql', 'syntax error', 'mysql', 'postgresql', 'oracle']
                },
                {
                    'type': VulnerabilityType.DIRECTORY_TRAVERSAL,
                    'severity': Severity.MEDIUM,
                    'title': 'Directory Traversal',
                    'description': 'HTTP service may allow directory traversal attacks',
                    'test_payloads': ['../../../etc/passwd', '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts'],
                    'indicators': ['root:', 'localhost', 'system32']
                }
            ],
            'ftp': [
                {
                    'type': VulnerabilityType.WEAK_AUTHENTICATION,
                    'severity': Severity.HIGH,
                    'title': 'Anonymous FTP Access',
                    'description': 'FTP service allows anonymous access',
                    'test_payloads': [],
                    'indicators': ['anonymous', '230 Login successful']
                }
            ],
            'ssh': [
                {
                    'type': VulnerabilityType.WEAK_AUTHENTICATION,
                    'severity': Severity.MEDIUM,
                    'title': 'SSH Weak Authentication',
                    'description': 'SSH service may have weak authentication mechanisms',
                    'test_payloads': [],
                    'indicators': ['password authentication', 'root login']
                }
            ],
            'dns': [
                {
                    'type': VulnerabilityType.AMPLIFICATION_VECTOR,
                    'severity': Severity.HIGH,
                    'title': 'DNS Amplification Vector',
                    'description': 'DNS service can be used for amplification attacks',
                    'test_payloads': [],
                    'indicators': ['recursion available']
                }
            ]
        }
    
    def _load_protocol_weaknesses(self) -> Dict[str, List[Dict[str, Any]]]:
        """Load protocol-specific weaknesses"""
        return {
            'TCP': [
                {
                    'type': VulnerabilityType.DENIAL_OF_SERVICE,
                    'severity': Severity.MEDIUM,
                    'title': 'TCP SYN Flood Susceptibility',
                    'description': 'TCP service may be vulnerable to SYN flood attacks',
                    'attack_vectors': ['syn_flood', 'connection_exhaustion']
                }
            ],
            'UDP': [
                {
                    'type': VulnerabilityType.REFLECTION_VECTOR,
                    'severity': Severity.MEDIUM,
                    'title': 'UDP Reflection Vector',
                    'description': 'UDP service can be used for reflection attacks',
                    'attack_vectors': ['udp_reflection', 'amplification']
                }
            ]
        }
    
    def _load_amplification_services(self) -> Dict[int, Dict[str, Any]]:
        """Load services known for amplification attacks"""
        return {
            53: {  # DNS
                'service': 'DNS',
                'amplification_factor': 28.0,
                'payload': b'\x00\x00\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03www\x07example\x03com\x00\x00\xff\x00\x01',
                'response_indicators': [b'\x81\x80']
            },
            123: {  # NTP
                'service': 'NTP',
                'amplification_factor': 556.9,
                'payload': b'\x17\x00\x03\x2a\x00\x00\x00\x00',
                'response_indicators': [b'\x97']
            },
            161: {  # SNMP
                'service': 'SNMP',
                'amplification_factor': 6.3,
                'payload': b'\x30\x26\x02\x01\x01\x04\x06\x70\x75\x62\x6c\x69\x63\xa5\x19\x02\x04\x00\x00\x00\x00\x02\x01\x00\x02\x01\x00\x30\x0b\x30\x09\x06\x05\x2b\x06\x01\x02\x01\x05\x00',
                'response_indicators': [b'\x30']
            },
            11211: {  # Memcached
                'service': 'Memcached',
                'amplification_factor': 51200.0,
                'payload': b'\x00\x00\x00\x00\x00\x01\x00\x00stats\r\n',
                'response_indicators': [b'STAT']
            },
            1900: {  # SSDP
                'service': 'SSDP',
                'amplification_factor': 30.8,
                'payload': b'M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: "ssdp:discover"\r\nST: upnp:rootdevice\r\nMX: 3\r\n\r\n',
                'response_indicators': [b'HTTP/1.1 200 OK']
            }
        }

class ProtocolScanner:
    """Scans for protocol-specific vulnerabilities"""
    
    def __init__(self):
        self.vuln_db = VulnerabilityDatabase()
        self.executor = ThreadPoolExecutor(max_workers=10)
    
    async def scan_http_vulnerabilities(self, ip: str, port: int) -> List[Vulnerability]:
        """Scan for HTTP-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Test for common web vulnerabilities
            http_vulns = self.vuln_db.service_vulnerabilities.get('http', [])
            
            for vuln_template in http_vulns:
                vuln = await self._test_http_vulnerability(ip, port, vuln_template)
                if vuln:
                    vulnerabilities.append(vuln)
            
            # Test for SSL/TLS vulnerabilities if HTTPS
            if port in [443, 8443]:
                ssl_vulns = await self._scan_ssl_vulnerabilities(ip, port)
                vulnerabilities.extend(ssl_vulns)
            
        except Exception as e:
            logger.debug(f"HTTP vulnerability scan error for {ip}:{port}: {e}")
        
        return vulnerabilities
    
    async def _test_http_vulnerability(self, ip: str, port: int, 
                                     vuln_template: Dict[str, Any]) -> Optional[Vulnerability]:
        """Test for specific HTTP vulnerability"""
        try:
            # Connect to HTTP service
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(ip, port),
                timeout=5.0
            )
            
            # Test each payload
            for payload in vuln_template.get('test_payloads', []):
                request = f"GET /?test={payload} HTTP/1.1\r\nHost: {ip}\r\n\r\n"
                writer.write(request.encode())
                await writer.drain()
                
                response = await asyncio.wait_for(reader.read(4096), timeout=3.0)
                response_str = response.decode('utf-8', errors='ignore')
                
                # Check for vulnerability indicators
                for indicator in vuln_template.get('indicators', []):
                    if indicator.lower() in response_str.lower():
                        writer.close()
                        await writer.wait_closed()
                        
                        return Vulnerability(
                            vuln_type=vuln_template['type'],
                            severity=vuln_template['severity'],
                            title=vuln_template['title'],
                            description=vuln_template['description'],
                            affected_service='http',
                            port=port,
                            protocol='TCP',
                            evidence=[f"Payload: {payload}", f"Response indicator: {indicator}"],
                            attack_vectors=['web_application_attack'],
                            remediation=['Input validation', 'Output encoding', 'WAF deployment']
                        )
            
            writer.close()
            await writer.wait_closed()
            
        except Exception as e:
            logger.debug(f"HTTP vulnerability test error: {e}")
        
        return None
    
    async def _scan_ssl_vulnerabilities(self, ip: str, port: int) -> List[Vulnerability]:
        """Scan for SSL/TLS vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Test SSL/TLS configuration
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            # Connect with SSL
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(ip, port, ssl=context),
                timeout=5.0
            )
            
            # Get SSL certificate information
            ssl_object = writer.get_extra_info('ssl_object')
            if ssl_object:
                cert = ssl_object.getpeercert()
                cipher = ssl_object.cipher()
                
                # Check for weak ciphers
                if cipher and len(cipher) >= 3:
                    cipher_name = cipher[0]
                    if any(weak in cipher_name.upper() for weak in ['RC4', 'DES', 'MD5']):
                        vulnerabilities.append(Vulnerability(
                            vuln_type=VulnerabilityType.INSECURE_TRANSPORT,
                            severity=Severity.HIGH,
                            title='Weak SSL/TLS Cipher',
                            description=f'Weak cipher detected: {cipher_name}',
                            affected_service='https',
                            port=port,
                            protocol='TCP',
                            evidence=[f"Cipher: {cipher_name}"],
                            attack_vectors=['ssl_downgrade', 'cipher_attack'],
                            remediation=['Update SSL configuration', 'Disable weak ciphers']
                        ))
                
                # Check certificate validity
                if cert:
                    # Check for self-signed certificates
                    if cert.get('issuer') == cert.get('subject'):
                        vulnerabilities.append(Vulnerability(
                            vuln_type=VulnerabilityType.INSECURE_TRANSPORT,
                            severity=Severity.MEDIUM,
                            title='Self-Signed Certificate',
                            description='SSL certificate is self-signed',
                            affected_service='https',
                            port=port,
                            protocol='TCP',
                            evidence=['Self-signed certificate detected'],
                            attack_vectors=['mitm_attack'],
                            remediation=['Use CA-signed certificate']
                        ))
            
            writer.close()
            await writer.wait_closed()
            
        except Exception as e:
            logger.debug(f"SSL vulnerability scan error: {e}")
        
        return vulnerabilities
    
    async def scan_dns_vulnerabilities(self, ip: str, port: int) -> List[Vulnerability]:
        """Scan for DNS-specific vulnerabilities"""
        vulnerabilities = []
        
        try:
            # Test for DNS amplification potential
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(3.0)
            
            # Send DNS query
            query = b'\x12\x34\x01\x00\x00\x01\x00\x00\x00\x00\x00\x00\x03www\x07example\x03com\x00\x00\x01\x00\x01'
            sock.sendto(query, (ip, port))
            
            try:
                response, addr = sock.recvfrom(1024)
                
                # Calculate amplification factor
                amplification_factor = len(response) / len(query)
                
                if amplification_factor > 2.0:  # Significant amplification
                    vulnerabilities.append(Vulnerability(
                        vuln_type=VulnerabilityType.AMPLIFICATION_VECTOR,
                        severity=Severity.HIGH,
                        title='DNS Amplification Vector',
                        description=f'DNS service provides {amplification_factor:.1f}x amplification',
                        affected_service='dns',
                        port=port,
                        protocol='UDP',
                        evidence=[f"Amplification factor: {amplification_factor:.1f}x"],
                        attack_vectors=['dns_amplification', 'reflection_attack'],
                        remediation=['Disable recursion', 'Rate limiting', 'Response rate limiting']
                    ))
                
                # Check for recursion
                if response[2] & 0x80:  # RA bit set
                    vulnerabilities.append(Vulnerability(
                        vuln_type=VulnerabilityType.CONFIGURATION_ERROR,
                        severity=Severity.MEDIUM,
                        title='DNS Recursion Enabled',
                        description='DNS server allows recursive queries',
                        affected_service='dns',
                        port=port,
                        protocol='UDP',
                        evidence=['Recursion available flag set'],
                        attack_vectors=['dns_cache_poisoning', 'dns_amplification'],
                        remediation=['Disable recursion for external queries']
                    ))
            
            except socket.timeout:
                pass
            
            sock.close()
            
        except Exception as e:
            logger.debug(f"DNS vulnerability scan error: {e}")
        
        return vulnerabilities
    
    async def scan_amplification_services(self, ip: str, port: int) -> List[Vulnerability]:
        """Scan for amplification service vulnerabilities"""
        vulnerabilities = []
        
        amp_service = self.vuln_db.amplification_services.get(port)
        if not amp_service:
            return vulnerabilities
        
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            sock.settimeout(3.0)
            
            # Send amplification test payload
            payload = amp_service['payload']
            sock.sendto(payload, (ip, port))
            
            try:
                response, addr = sock.recvfrom(65536)
                
                # Check for expected response indicators
                response_valid = False
                for indicator in amp_service['response_indicators']:
                    if indicator in response:
                        response_valid = True
                        break
                
                if response_valid:
                    actual_amplification = len(response) / len(payload)
                    expected_amplification = amp_service['amplification_factor']
                    
                    severity = Severity.HIGH if actual_amplification > 10 else Severity.MEDIUM
                    
                    vulnerabilities.append(Vulnerability(
                        vuln_type=VulnerabilityType.AMPLIFICATION_VECTOR,
                        severity=severity,
                        title=f'{amp_service["service"]} Amplification Vector',
                        description=f'{amp_service["service"]} service provides {actual_amplification:.1f}x amplification',
                        affected_service=amp_service['service'].lower(),
                        port=port,
                        protocol='UDP',
                        evidence=[
                            f"Amplification factor: {actual_amplification:.1f}x",
                            f"Expected factor: {expected_amplification:.1f}x"
                        ],
                        attack_vectors=['amplification_attack', 'reflection_attack'],
                        remediation=['Disable service', 'Rate limiting', 'Access control']
                    ))
            
            except socket.timeout:
                pass
            
            sock.close()
            
        except Exception as e:
            logger.debug(f"Amplification service scan error for {ip}:{port}: {e}")
        
        return vulnerabilities

class AttackSurfaceAnalyzer:
    """Analyzes target attack surface"""
    
    def __init__(self):
        self.vuln_db = VulnerabilityDatabase()
    
    def analyze_attack_surface(self, target_info: TargetInfo, 
                             vulnerabilities: List[Vulnerability]) -> AttackSurface:
        """Analyze target attack surface"""
        surface = AttackSurface()
        
        # Count total and exposed services
        surface.total_services = len(target_info.ports)
        surface.exposed_services = [
            f"{svc.service_name or 'unknown'}:{svc.port}/{svc.protocol}"
            for svc in target_info.ports if svc.state == "open"
        ]
        
        # Analyze attack vectors by protocol
        surface.attack_vectors = self._identify_attack_vectors(target_info.ports)
        
        # Calculate amplification and reflection potential
        surface.amplification_potential = self._calculate_amplification_potential(
            target_info.ports, vulnerabilities
        )
        surface.reflection_potential = self._calculate_reflection_potential(
            target_info.ports
        )
        
        # Calculate DoS susceptibility
        surface.dos_susceptibility = self._calculate_dos_susceptibility(
            target_info.ports, vulnerabilities
        )
        
        # Calculate overall risk score
        surface.overall_risk_score = self._calculate_risk_score(surface, vulnerabilities)
        
        return surface
    
    def _identify_attack_vectors(self, services: List[ServiceInfo]) -> Dict[str, List[str]]:
        """Identify available attack vectors"""
        vectors = {}
        
        for service in services:
            if service.state != "open":
                continue
            
            service_vectors = []
            
            # Protocol-based vectors
            if service.protocol.upper() == "TCP":
                service_vectors.extend([
                    'tcp_syn_flood', 'connection_exhaustion', 'slowloris'
                ])
            elif service.protocol.upper() == "UDP":
                service_vectors.extend([
                    'udp_flood', 'reflection_attack'
                ])
            
            # Service-specific vectors
            if service.service_name:
                if service.service_name.lower() in ['http', 'https']:
                    service_vectors.extend([
                        'http_flood', 'slowloris', 'http_post_flood'
                    ])
                elif service.service_name.lower() == 'dns':
                    service_vectors.extend([
                        'dns_amplification', 'dns_flood'
                    ])
                elif service.service_name.lower() == 'ssh':
                    service_vectors.extend([
                        'ssh_brute_force', 'ssh_connection_flood'
                    ])
            
            # Port-specific vectors
            if service.port in self.vuln_db.amplification_services:
                service_vectors.append('amplification_attack')
            
            vectors[f"{service.port}/{service.protocol}"] = service_vectors
        
        return vectors
    
    def _calculate_amplification_potential(self, services: List[ServiceInfo], 
                                         vulnerabilities: List[Vulnerability]) -> float:
        """Calculate amplification attack potential"""
        potential = 0.0
        
        # Check for amplification vulnerabilities
        amp_vulns = [v for v in vulnerabilities if v.vuln_type == VulnerabilityType.AMPLIFICATION_VECTOR]
        
        for vuln in amp_vulns:
            # Extract amplification factor from evidence
            for evidence in vuln.evidence:
                if 'amplification factor' in evidence.lower():
                    try:
                        factor_str = evidence.split(':')[1].strip().replace('x', '')
                        factor = float(factor_str)
                        potential = max(potential, min(factor / 100.0, 1.0))  # Normalize to 0-1
                    except:
                        potential = max(potential, 0.5)  # Default moderate potential
        
        # Check for services known for amplification
        for service in services:
            if service.state == "open" and service.port in self.vuln_db.amplification_services:
                expected_factor = self.vuln_db.amplification_services[service.port]['amplification_factor']
                potential = max(potential, min(expected_factor / 100.0, 1.0))
        
        return potential
    
    def _calculate_reflection_potential(self, services: List[ServiceInfo]) -> float:
        """Calculate reflection attack potential"""
        potential = 0.0
        
        # UDP services have reflection potential
        udp_services = [s for s in services if s.protocol.upper() == "UDP" and s.state == "open"]
        
        if udp_services:
            # Higher potential with more UDP services
            potential = min(len(udp_services) * 0.2, 1.0)
        
        return potential
    
    def _calculate_dos_susceptibility(self, services: List[ServiceInfo], 
                                    vulnerabilities: List[Vulnerability]) -> float:
        """Calculate denial of service susceptibility"""
        susceptibility = 0.0
        
        # Base susceptibility from exposed services
        open_services = [s for s in services if s.state == "open"]
        if open_services:
            susceptibility = min(len(open_services) * 0.1, 0.5)
        
        # Increase based on DoS vulnerabilities
        dos_vulns = [v for v in vulnerabilities if v.vuln_type == VulnerabilityType.DENIAL_OF_SERVICE]
        susceptibility += len(dos_vulns) * 0.2
        
        # Increase based on amplification potential
        amp_vulns = [v for v in vulnerabilities if v.vuln_type == VulnerabilityType.AMPLIFICATION_VECTOR]
        susceptibility += len(amp_vulns) * 0.3
        
        return min(susceptibility, 1.0)
    
    def _calculate_risk_score(self, surface: AttackSurface, 
                            vulnerabilities: List[Vulnerability]) -> float:
        """Calculate overall risk score"""
        score = 0.0
        
        # Weight by vulnerability severity
        severity_weights = {
            Severity.CRITICAL: 1.0,
            Severity.HIGH: 0.8,
            Severity.MEDIUM: 0.5,
            Severity.LOW: 0.2,
            Severity.INFO: 0.1
        }
        
        for vuln in vulnerabilities:
            score += severity_weights.get(vuln.severity, 0.1)
        
        # Normalize by number of services
        if surface.total_services > 0:
            score = score / surface.total_services
        
        # Factor in attack surface characteristics
        score += surface.amplification_potential * 0.3
        score += surface.reflection_potential * 0.2
        score += surface.dos_susceptibility * 0.2
        
        return min(score, 1.0)

class VulnerabilityScanner:
    """Main vulnerability scanner orchestrator"""
    
    def __init__(self):
        self.protocol_scanner = ProtocolScanner()
        self.surface_analyzer = AttackSurfaceAnalyzer()
        self.vuln_db = VulnerabilityDatabase()
    
    async def scan_vulnerabilities(self, target_info: TargetInfo, 
                                 service_fingerprints: List[ServiceFingerprint] = None) -> VulnerabilityReport:
        """Perform comprehensive vulnerability scan"""
        report = VulnerabilityReport(target=target_info.original_target)
        
        if not target_info.ip_addresses:
            return report
        
        primary_ip = target_info.ip_addresses[0]
        
        # Scan each open service
        for service in target_info.ports:
            if service.state == "open":
                service_vulns = await self._scan_service_vulnerabilities(
                    primary_ip, service, service_fingerprints
                )
                report.vulnerabilities.extend(service_vulns)
        
        # Analyze attack surface
        report.attack_surface = self.surface_analyzer.analyze_attack_surface(
            target_info, report.vulnerabilities
        )
        
        # Generate risk summary
        report.risk_summary = self._generate_risk_summary(report.vulnerabilities)
        
        # Generate recommendations
        report.recommendations = self._generate_recommendations(
            report.vulnerabilities, report.attack_surface
        )
        
        # Set scan coverage
        report.scan_coverage = self._calculate_scan_coverage(target_info.ports)
        
        return report
    
    async def _scan_service_vulnerabilities(self, ip: str, service: ServiceInfo, 
                                          fingerprints: List[ServiceFingerprint] = None) -> List[Vulnerability]:
        """Scan vulnerabilities for a specific service"""
        vulnerabilities = []
        
        try:
            # Service-specific vulnerability scans
            if service.service_name:
                if service.service_name.lower() in ['http', 'https']:
                    http_vulns = await self.protocol_scanner.scan_http_vulnerabilities(ip, service.port)
                    vulnerabilities.extend(http_vulns)
                elif service.service_name.lower() == 'dns':
                    dns_vulns = await self.protocol_scanner.scan_dns_vulnerabilities(ip, service.port)
                    vulnerabilities.extend(dns_vulns)
            
            # Check for amplification services
            amp_vulns = await self.protocol_scanner.scan_amplification_services(ip, service.port)
            vulnerabilities.extend(amp_vulns)
            
            # Protocol-level vulnerabilities
            protocol_vulns = self._scan_protocol_vulnerabilities(service)
            vulnerabilities.extend(protocol_vulns)
            
            # Version-based vulnerabilities (if fingerprint available)
            if fingerprints:
                version_vulns = self._scan_version_vulnerabilities(service, fingerprints)
                vulnerabilities.extend(version_vulns)
        
        except Exception as e:
            logger.debug(f"Service vulnerability scan error for {ip}:{service.port}: {e}")
        
        return vulnerabilities
    
    def _scan_protocol_vulnerabilities(self, service: ServiceInfo) -> List[Vulnerability]:
        """Scan for protocol-level vulnerabilities"""
        vulnerabilities = []
        
        protocol_vulns = self.vuln_db.protocol_weaknesses.get(service.protocol.upper(), [])
        
        for vuln_template in protocol_vulns:
            vuln = Vulnerability(
                vuln_type=vuln_template['type'],
                severity=vuln_template['severity'],
                title=vuln_template['title'],
                description=vuln_template['description'],
                affected_service=service.service_name or 'unknown',
                port=service.port,
                protocol=service.protocol,
                attack_vectors=vuln_template.get('attack_vectors', []),
                remediation=['Protocol hardening', 'Rate limiting', 'Monitoring']
            )
            vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _scan_version_vulnerabilities(self, service: ServiceInfo, 
                                    fingerprints: List[ServiceFingerprint]) -> List[Vulnerability]:
        """Scan for version-specific vulnerabilities"""
        vulnerabilities = []
        
        # Find matching fingerprint
        matching_fingerprint = None
        for fp in fingerprints:
            if (fp.service_name == service.service_name and 
                any(vuln for vuln in fp.vulnerabilities)):
                matching_fingerprint = fp
                break
        
        if matching_fingerprint and matching_fingerprint.vulnerabilities:
            for cve in matching_fingerprint.vulnerabilities:
                vuln = Vulnerability(
                    vuln_type=VulnerabilityType.OUTDATED_SOFTWARE,
                    severity=Severity.MEDIUM,  # Default, would need CVE database lookup
                    title=f'Known Vulnerability: {cve}',
                    description=f'Service version has known vulnerability {cve}',
                    affected_service=service.service_name or 'unknown',
                    port=service.port,
                    protocol=service.protocol,
                    cve_references=[cve],
                    attack_vectors=['exploit'],
                    remediation=['Update software', 'Apply security patches']
                )
                vulnerabilities.append(vuln)
        
        return vulnerabilities
    
    def _generate_risk_summary(self, vulnerabilities: List[Vulnerability]) -> Dict[str, int]:
        """Generate risk summary by severity"""
        summary = {
            'critical': 0,
            'high': 0,
            'medium': 0,
            'low': 0,
            'info': 0
        }
        
        for vuln in vulnerabilities:
            summary[vuln.severity.value] += 1
        
        return summary
    
    def _generate_recommendations(self, vulnerabilities: List[Vulnerability], 
                                attack_surface: AttackSurface) -> List[str]:
        """Generate security recommendations"""
        recommendations = set()
        
        # Vulnerability-based recommendations
        for vuln in vulnerabilities:
            recommendations.update(vuln.remediation)
        
        # Attack surface-based recommendations
        if attack_surface.amplification_potential > 0.5:
            recommendations.add("Implement rate limiting for UDP services")
            recommendations.add("Consider disabling unnecessary UDP services")
        
        if attack_surface.dos_susceptibility > 0.7:
            recommendations.add("Deploy DDoS protection service")
            recommendations.add("Implement connection rate limiting")
        
        if len(attack_surface.exposed_services) > 10:
            recommendations.add("Reduce attack surface by disabling unnecessary services")
            recommendations.add("Implement network segmentation")
        
        # General recommendations
        recommendations.update([
            "Regular security assessments",
            "Keep software updated",
            "Monitor network traffic",
            "Implement intrusion detection"
        ])
        
        return list(recommendations)
    
    def _calculate_scan_coverage(self, services: List[ServiceInfo]) -> Dict[str, bool]:
        """Calculate scan coverage"""
        coverage = {
            'port_scan': True,
            'service_detection': True,
            'vulnerability_scan': True,
            'ssl_scan': any(s.port in [443, 8443] for s in services),
            'web_scan': any(s.service_name in ['http', 'https'] for s in services if s.service_name),
            'dns_scan': any(s.port == 53 for s in services),
            'amplification_scan': True
        }
        
        return coverage