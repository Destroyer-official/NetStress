// DPDK PMD Static Linking Support for NetStress Titanium v3.0
// **Validates: Requirements 10.2** - Include supported NIC PMDs, configure PMD initialization, handle PMD detection at runtime

use std::collections::HashMap;
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int, c_uint, c_void};
use std::sync::Once;
use tracing::{debug, error, info, warn};

// DPDK PMD function signatures (would be generated by bindgen in real implementation)
#[cfg(feature = "dpdk")]
extern "C" {
    // Core DPDK initialization
    fn rte_eal_init(argc: c_int, argv: *mut *mut c_char) -> c_int;
    fn rte_eal_cleanup() -> c_int;

    // PMD registration functions
    fn rte_pmd_register(pmd: *const RtePmdDriver) -> c_int;
    fn rte_dev_probe(devargs: *const c_char) -> c_int;

    // Ethernet device functions
    fn rte_eth_dev_count_avail() -> c_uint;
    fn rte_eth_dev_info_get(port_id: c_uint, dev_info: *mut RteEthDevInfo) -> c_int;
    fn rte_eth_dev_configure(
        port_id: c_uint,
        nb_rx_q: c_uint,
        nb_tx_q: c_uint,
        eth_conf: *const RteEthConf,
    ) -> c_int;

    // Memory pool functions
    fn rte_pktmbuf_pool_create(
        name: *const c_char,
        n: c_uint,
        cache_size: c_uint,
        priv_size: c_uint,
        data_room_size: c_uint,
        socket_id: c_int,
    ) -> *mut RteMempool;
}

// DPDK structure definitions (simplified)
#[repr(C)]
struct RtePmdDriver {
    name: *const c_char,
    probe: extern "C" fn(*const c_char) -> c_int,
    remove: extern "C" fn(*const c_char) -> c_int,
}

#[repr(C)]
struct RteEthDevInfo {
    device: *mut c_void,
    driver_name: *const c_char,
    max_rx_queues: c_uint,
    max_tx_queues: c_uint,
    max_rx_pktlen: c_uint,
    max_mtu: c_uint,
}

#[repr(C)]
struct RteEthConf {
    link_speeds: c_uint,
    rxmode: RteEthRxmode,
    txmode: RteEthTxmode,
}

#[repr(C)]
struct RteEthRxmode {
    mq_mode: c_uint,
    max_rx_pkt_len: c_uint,
    offloads: u64,
}

#[repr(C)]
struct RteEthTxmode {
    mq_mode: c_uint,
    offloads: u64,
}

#[repr(C)]
struct RteMempool {
    _private: [u8; 0],
}

/// Supported DPDK PMDs for static linking
#[derive(Debug, Clone)]
pub enum SupportedPmd {
    // Intel PMDs
    E1000, // Intel 1GbE
    IGB,   // Intel IGB
    IXGBE, // Intel 10GbE
    I40E,  // Intel 40GbE
    ICE,   // Intel 100GbE

    // Mellanox PMDs
    MLX4, // Mellanox ConnectX-3
    MLX5, // Mellanox ConnectX-4/5/6

    // Broadcom PMDs
    BNXT, // Broadcom NetXtreme

    // Virtual PMDs
    VIRTIO,  // VirtIO
    VMXNET3, // VMware vmxnet3

    // Generic PMDs
    AF_PACKET, // Linux AF_PACKET
    TAP,       // TAP interface
    NULL,      // Null PMD for testing
}

impl SupportedPmd {
    fn driver_name(&self) -> &'static str {
        match self {
            SupportedPmd::E1000 => "net_e1000_em",
            SupportedPmd::IGB => "net_e1000_igb",
            SupportedPmd::IXGBE => "net_ixgbe",
            SupportedPmd::I40E => "net_i40e",
            SupportedPmd::ICE => "net_ice",
            SupportedPmd::MLX4 => "net_mlx4",
            SupportedPmd::MLX5 => "net_mlx5",
            SupportedPmd::BNXT => "net_bnxt",
            SupportedPmd::VIRTIO => "net_virtio",
            SupportedPmd::VMXNET3 => "net_vmxnet3",
            SupportedPmd::AF_PACKET => "net_af_packet",
            SupportedPmd::TAP => "net_tap",
            SupportedPmd::NULL => "net_null",
        }
    }

    fn is_hardware(&self) -> bool {
        matches!(
            self,
            SupportedPmd::E1000
                | SupportedPmd::IGB
                | SupportedPmd::IXGBE
                | SupportedPmd::I40E
                | SupportedPmd::ICE
                | SupportedPmd::MLX4
                | SupportedPmd::MLX5
                | SupportedPmd::BNXT
        )
    }
}

/// DPDK PMD Manager
pub struct DpdkPmdManager {
    initialized: bool,
    available_pmds: HashMap<String, SupportedPmd>,
    detected_devices: Vec<DpdkDevice>,
}

#[derive(Debug, Clone)]
pub struct DpdkDevice {
    pub port_id: u32,
    pub driver_name: String,
    pub pmd_type: SupportedPmd,
    pub max_rx_queues: u32,
    pub max_tx_queues: u32,
    pub max_pkt_len: u32,
    pub is_hardware: bool,
}

static DPDK_INIT: Once = Once::new();

impl DpdkPmdManager {
    pub fn new() -> Self {
        Self {
            initialized: false,
            available_pmds: HashMap::new(),
            detected_devices: Vec::new(),
        }
    }

    /// Initialize DPDK EAL and register static PMDs
    pub fn initialize(&mut self) -> Result<(), DpdkError> {
        if self.initialized {
            return Ok(());
        }

        DPDK_INIT.call_once(|| {
            info!("Initializing DPDK EAL with static PMDs");
        });

        #[cfg(feature = "dpdk")]
        {
            // Initialize DPDK EAL
            let args = vec![
                CString::new("netstress").unwrap(),
                CString::new("--no-huge").unwrap(), // No hugepages for portability
                CString::new("--no-pci").unwrap(),  // No PCI scanning initially
                CString::new("--vdev=net_null0").unwrap(), // Always include null PMD
            ];

            let mut argv: Vec<*mut c_char> =
                args.iter().map(|s| s.as_ptr() as *mut c_char).collect();

            let ret = unsafe { rte_eal_init(argv.len() as c_int, argv.as_mut_ptr()) };

            if ret < 0 {
                error!("Failed to initialize DPDK EAL: {}", ret);
                return Err(DpdkError::InitializationFailed);
            }

            info!("DPDK EAL initialized successfully");
        }

        // Register supported PMDs
        self.register_static_pmds()?;

        // Detect available devices
        self.detect_devices()?;

        self.initialized = true;
        Ok(())
    }

    /// Register all statically linked PMDs
    fn register_static_pmds(&mut self) -> Result<(), DpdkError> {
        let supported_pmds = vec![
            SupportedPmd::E1000,
            SupportedPmd::IGB,
            SupportedPmd::IXGBE,
            SupportedPmd::I40E,
            SupportedPmd::ICE,
            SupportedPmd::MLX4,
            SupportedPmd::MLX5,
            SupportedPmd::BNXT,
            SupportedPmd::VIRTIO,
            SupportedPmd::VMXNET3,
            SupportedPmd::AF_PACKET,
            SupportedPmd::TAP,
            SupportedPmd::NULL,
        ];

        for pmd in supported_pmds {
            let driver_name = pmd.driver_name().to_string();
            self.available_pmds.insert(driver_name.clone(), pmd.clone());

            debug!(
                "Registered PMD: {} ({})",
                driver_name,
                if pmd.is_hardware() {
                    "hardware"
                } else {
                    "virtual"
                }
            );
        }

        info!("Registered {} static PMDs", self.available_pmds.len());
        Ok(())
    }

    /// Detect available DPDK devices at runtime
    fn detect_devices(&mut self) -> Result<(), DpdkError> {
        #[cfg(feature = "dpdk")]
        {
            let device_count = unsafe { rte_eth_dev_count_avail() };
            info!("Detected {} DPDK devices", device_count);

            for port_id in 0..device_count {
                let mut dev_info = RteEthDevInfo {
                    device: std::ptr::null_mut(),
                    driver_name: std::ptr::null(),
                    max_rx_queues: 0,
                    max_tx_queues: 0,
                    max_rx_pktlen: 0,
                    max_mtu: 0,
                };

                let ret = unsafe { rte_eth_dev_info_get(port_id, &mut dev_info) };

                if ret == 0 && !dev_info.driver_name.is_null() {
                    let driver_name = unsafe {
                        CStr::from_ptr(dev_info.driver_name)
                            .to_string_lossy()
                            .to_string()
                    };

                    if let Some(pmd_type) = self.available_pmds.get(&driver_name) {
                        let device = DpdkDevice {
                            port_id,
                            driver_name: driver_name.clone(),
                            pmd_type: pmd_type.clone(),
                            max_rx_queues: dev_info.max_rx_queues,
                            max_tx_queues: dev_info.max_tx_queues,
                            max_pkt_len: dev_info.max_rx_pktlen,
                            is_hardware: pmd_type.is_hardware(),
                        };

                        self.detected_devices.push(device);
                        info!("Detected device: {} (port {})", driver_name, port_id);
                    } else {
                        warn!("Unknown PMD driver: {}", driver_name);
                    }
                }
            }
        }

        #[cfg(not(feature = "dpdk"))]
        {
            // Fallback: create virtual null device for testing
            let device = DpdkDevice {
                port_id: 0,
                driver_name: "net_null".to_string(),
                pmd_type: SupportedPmd::NULL,
                max_rx_queues: 1,
                max_tx_queues: 1,
                max_pkt_len: 1518,
                is_hardware: false,
            };

            self.detected_devices.push(device);
            info!("DPDK not available, using null PMD fallback");
        }

        Ok(())
    }

    /// Get list of detected devices
    pub fn get_devices(&self) -> &[DpdkDevice] {
        &self.detected_devices
    }

    /// Get hardware devices only
    pub fn get_hardware_devices(&self) -> Vec<&DpdkDevice> {
        self.detected_devices
            .iter()
            .filter(|dev| dev.is_hardware)
            .collect()
    }

    /// Check if a specific PMD is available
    pub fn is_pmd_available(&self, pmd: &SupportedPmd) -> bool {
        self.available_pmds
            .values()
            .any(|p| std::mem::discriminant(p) == std::mem::discriminant(pmd))
    }

    /// Cleanup DPDK resources
    pub fn cleanup(&mut self) -> Result<(), DpdkError> {
        if !self.initialized {
            return Ok(());
        }

        #[cfg(feature = "dpdk")]
        {
            let ret = unsafe { rte_eal_cleanup() };
            if ret < 0 {
                error!("Failed to cleanup DPDK EAL: {}", ret);
                return Err(DpdkError::CleanupFailed);
            }
        }

        self.initialized = false;
        self.detected_devices.clear();
        info!("DPDK PMD manager cleaned up");

        Ok(())
    }
}

impl Drop for DpdkPmdManager {
    fn drop(&mut self) {
        let _ = self.cleanup();
    }
}

#[derive(Debug, thiserror::Error)]
pub enum DpdkError {
    #[error("DPDK initialization failed")]
    InitializationFailed,

    #[error("DPDK cleanup failed")]
    CleanupFailed,

    #[error("PMD registration failed: {0}")]
    PmdRegistrationFailed(String),

    #[error("Device detection failed")]
    DeviceDetectionFailed,

    #[error("DPDK not available (feature disabled)")]
    NotAvailable,
}

// Build script integration for static PMD linking
#[cfg(feature = "dpdk")]
pub fn configure_static_linking() {
    // This would be called from build.rs to configure static linking
    println!("cargo:rustc-link-lib=static=dpdk");
    println!("cargo:rustc-link-lib=static=rte_pmd_e1000");
    println!("cargo:rustc-link-lib=static=rte_pmd_ixgbe");
    println!("cargo:rustc-link-lib=static=rte_pmd_i40e");
    println!("cargo:rustc-link-lib=static=rte_pmd_ice");
    println!("cargo:rustc-link-lib=static=rte_pmd_mlx4");
    println!("cargo:rustc-link-lib=static=rte_pmd_mlx5");
    println!("cargo:rustc-link-lib=static=rte_pmd_bnxt");
    println!("cargo:rustc-link-lib=static=rte_pmd_virtio");
    println!("cargo:rustc-link-lib=static=rte_pmd_vmxnet3");
    println!("cargo:rustc-link-lib=static=rte_pmd_af_packet");
    println!("cargo:rustc-link-lib=static=rte_pmd_tap");
    println!("cargo:rustc-link-lib=static=rte_pmd_null");
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pmd_manager_creation() {
        let manager = DpdkPmdManager::new();
        assert!(!manager.initialized);
        assert_eq!(manager.available_pmds.len(), 0);
        assert_eq!(manager.detected_devices.len(), 0);
    }

    #[test]
    fn test_supported_pmd_properties() {
        assert_eq!(SupportedPmd::IXGBE.driver_name(), "net_ixgbe");
        assert!(SupportedPmd::IXGBE.is_hardware());
        assert!(!SupportedPmd::NULL.is_hardware());
    }
}
